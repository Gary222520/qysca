package nju.edu.cn.qysca.service.vulnerability;

import cn.hutool.core.util.StrUtil;
import nju.edu.cn.qysca.dao.application.AppComponentDao;
import nju.edu.cn.qysca.dao.application.ApplicationDao;
import nju.edu.cn.qysca.dao.vulnerability.*;
import nju.edu.cn.qysca.domain.application.dos.AppComponentDO;
import nju.edu.cn.qysca.domain.application.dos.ApplicationDO;
import nju.edu.cn.qysca.domain.vulnerability.dos.*;
import nju.edu.cn.qysca.domain.vulnerability.dtos.VulnerabilityBriefDTO;
import nju.edu.cn.qysca.domain.vulnerability.dtos.VulnerabilityDTO;
import nju.edu.cn.qysca.exception.PlatformException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;

@Service
public class VulnerabilityServiceImpl implements VulnerabilityService{
    @Autowired
    private CveCpeDao cveCpeDao;

    @Autowired
    private ApplicationDao applicationDao;

    @Autowired
    private AppComponentDao appComponentDao;

    @Autowired
    private CveDao cveDao;

    @Autowired
    private CweDao cweDao;

    @Autowired
    private CnvdDao cnvdDao;

    /**
     * 根据cve id查找对应的漏洞信息
     *
     * @param cveId cve id
     * @return 漏洞详细信息
     */
    @Override
    public VulnerabilityDTO findVulnerabilityById(String cveId) {
        CveDO ans=cveDao.findOneByCveId(cveId);
        if(null==ans){
            throw new PlatformException(500,"无此漏洞信息记录");
        }
        CnvdDO cnvdDO=cnvdDao.findOneByCveId(cveId);
        VulnerabilityDTO res=new VulnerabilityDTO();
        res.setCve(ans);
        res.setCnvd(cnvdDO);
        return res;
    }

    /**
     * 获取组件漏洞信息
     *
     * @param name     组件名称
     * @param version  组件版本
     * @param language 组件语言
     * @return 漏洞id列表
     */
    @Override
    public List<String> findVulnerabilities(String name, String version, String language) {
        // 构造含版本和不含版本的潜在cpe
        String cpe=buildCpe(name,version,language);
        String cpeWithoutVersion=buildCpeWithoutVersion(name,language);
        List<String> ans=new ArrayList<>();
        // 根据潜在cpe做相似度查询
        List<CveCpeDO> cveCpeDOList=new ArrayList<>();
        List<CveCpeDO> similarity1=cveCpeDao.findByUriSimilarity(cpe);
        List<CveCpeDO> similarity2=cveCpeDao.findByUriSimilarity(cpeWithoutVersion);
        if(null!=similarity1 && similarity1.size()>0){
            cveCpeDOList.addAll(similarity1);
        }
        if(null!=similarity2 && similarity2.size()>0){
            cveCpeDOList.addAll(similarity2);
        }
        // 检查版本范围及是否为漏洞等信息，构造结果集
        String versionClean= (version.startsWith("v") || version.startsWith("V")) ? version.substring(1) : version;
        for(CveCpeDO cveCpeDO:cveCpeDOList){
            if(!cveCpeDO.getVulnerable()){
                continue;
            }
            // 防止名称相近的误判
            String[] nameSplit=name.split("/");
            if(nameSplit.length>1){
                int flag=0;
                for(String nameSplitItem:nameSplit){
                    if(cveCpeDO.getUri().contains(nameSplitItem)){
                        flag++;
                    }
                }
                if(flag<nameSplit.length/2){
                    continue;
                }
            }
            if(cveCpeDO.getVersionStart()==null && cveCpeDO.getVersionEnd()==null){
                if(!cveCpeDO.getUri().contains(versionClean)){
                    continue;
                }
            }
            if(cveCpeDO.getVersionStart()!=null){
                if(cveCpeDO.getStartInclude()){
                    if(versionClean.compareTo(cveCpeDO.getVersionStart())<0){
                        continue;
                    }
                }
                else{
                    if(versionClean.compareTo(cveCpeDO.getVersionStart())<=0){
                        continue;
                    }
                }
            }
            if(cveCpeDO.getVersionEnd()!=null){
                if(cveCpeDO.getEndInclude()){
                    if(versionClean.compareTo(cveCpeDO.getVersionEnd())>0){
                        continue;
                    }
                }
                else {
                    if(versionClean.compareTo(cveCpeDO.getVersionEnd())>=0){
                        continue;
                    }
                }
            }
            ans.add(cveCpeDO.getCveId());
        }
        Collections.sort(ans);
        return ans;
    }

    /**
     * 在应用中增加漏洞信息
     * @param name 应用名称
     * @param version 应用版本
     * @param cveId 漏洞Id
     * @return 在应用中增加漏洞信息是否成功
     */
    @Override
    @Transactional
    public Boolean addAppVulnerability(String name, String version, String cveId) {
        ApplicationDO applicationDO = applicationDao.findByNameAndVersion(name, version);
        if(applicationDO.getRelease() || applicationDO.getLock()){
            throw new PlatformException(500, "组件已经发布或锁定，禁止更新");
        }
        CveDO cveDO = cveDao.findOneByCveId(cveId);
        if(cveDO==null) {
            throw new PlatformException(500, "漏洞不存在");
        }
        Set<String> vulnerabilitySet = new HashSet<>(Arrays.asList(applicationDO.getVulnerabilities()));
        vulnerabilitySet.add(cveId);
        applicationDO.setVulnerabilities(vulnerabilitySet.toArray(new String[0]));
        applicationDao.save(applicationDO);
        AppComponentDO appComponentDO = appComponentDao.findByNameAndVersion(name, version);
        if(appComponentDO != null) {
            appComponentDO.setVulnerabilities(vulnerabilitySet.toArray(new String[0]));
            appComponentDao.save(appComponentDO);
        }
        return true;
    }


    /**
     * 在应用中删除漏洞信息
     * @param name 应用名称
     * @param version 应用版本
     * @param cveId 漏洞Id
     * @return 在应用中删除漏洞信息是否成功
     */
    @Override
    @Transactional
    public Boolean deleteAppVulnerability(String name, String version, String cveId) {
        ApplicationDO applicationDO = applicationDao.findByNameAndVersion(name, version);
        if(applicationDO.getRelease() || applicationDO.getLock()){
            throw new PlatformException(500, "组件已经发布或锁定，禁止更新");
        }
        Set<String> vulnerabilitySet = new HashSet<>(Arrays.asList(applicationDO.getVulnerabilities()));
        vulnerabilitySet.remove(cveId);
        applicationDO.setVulnerabilities(vulnerabilitySet.toArray(new String[0]));
        applicationDao.save(applicationDO);
        AppComponentDO appComponentDO = appComponentDao.findByNameAndVersion(name, version);
        if(appComponentDO != null) {
            appComponentDO.setVulnerabilities(vulnerabilitySet.toArray(new String[0]));
            appComponentDao.save(appComponentDO);
        }
        return true;
    }

    /**
     * 分页查询应用漏洞列表
     *
     * @param name    应用名称
     * @param version 应用版本
     * @param page    页号
     * @param size    页大小
     * @return 漏洞简明信息列表分页结果
     **/
    @Override
    public Page<VulnerabilityBriefDTO> getVulnerabilityList(String name, String version, int page, int size) {
        Pageable pageable = PageRequest.of(page - 1, size);
        ApplicationDO applicationDO = applicationDao.findByNameAndVersion(name, version);
        if (null == applicationDO) {
            throw new PlatformException(500, "无此应用");
        }
        Page<CveDO> tmpAns=cveDao.getCveList(Arrays.asList(applicationDO.getVulnerabilities()), pageable);
        List<VulnerabilityBriefDTO> ansList=new ArrayList<>();
        for(CveDO cveDO:tmpAns){
            ansList.add(buildVulnerabilityBriefInfo(cveDO));
        }
        return new PageImpl<>(ansList,pageable,tmpAns.getTotalElements());
    }

    /**
     * 根据cve id检索漏洞库数据
     * @param cveId cve id
     * @param page    页号
     * @param size    页大小
     * @return 漏洞简明信息
     */
    @Override
    public Page<VulnerabilityBriefDTO> searchVulnerability(String cveId, int page, int size) {
        Pageable pageable = PageRequest.of(page - 1, size);
        Page<CveDO> tmpAns=cveDao.getCvePage(cveId,pageable);
        List<VulnerabilityBriefDTO> ansList=new ArrayList<>();
        for(CveDO cveDO:tmpAns){
            ansList.add(buildVulnerabilityBriefInfo(cveDO));
        }
        return new PageImpl<>(ansList,pageable,tmpAns.getTotalElements());
    }

    /**
     * 根据cwe id查找对应的漏洞类型信息
     *
     * @param cweId cwe id
     * @return cwe漏洞类型信息
     */
    @Override
    public CweDO findCweById(String cweId) {
        CweDO ans=cweDao.findOneByCweId(cweId);
        if(null==ans){
            throw new PlatformException(500,"无此漏洞类型信息记录");
        }
        return ans;
    }

    /**
     * 根据组件名称、版本、语言构造cpe uri
     * @param name 名称
     * @param version 版本
     * @param language 语言
     * @return cpe uri
     */
    private String buildCpe(String name, String version, String language){
        String cpe="";
        String versionClean= (version.startsWith("v") || version.startsWith("V")) ? version.substring(1) : version;
        switch (language){
            case "java":
                String jProducts=name.replace("/",":");
                jProducts= StrUtil.toUnderlineCase(jProducts);
                cpe="cpe:2.3:a:"+jProducts+":"+versionClean+":*:*:*:*:*:*:*";
                break;
            case "javaScript":
                String jsProducts=name.replace("/",":");
                cpe="cpe:2.3:a:"+jsProducts+":"+versionClean+":*:*:*:*:node.js:*:*";
                break;
            case "golang":
                if(name.startsWith("github.com/")){
                    String gProducts=name.substring(11);
                    gProducts=gProducts.replace("/",":");
                    cpe="cpe:2.3:a:"+gProducts+":"+versionClean+":*:*:*:*:*:*:*";
                }
                break;
            case "python":
                String pyProducts=name.replace("/",":");
                cpe="cpe:2.3:a:"+pyProducts+":"+versionClean+":*:*:*:*:*:*:*";
                break;
            default:
                break;
        }
        return cpe;
    }

    /**
     * 根据组件名称、版本、语言构造不含version的cpe uri
     * @param name 名称
     * @param language 语言
     * @return cpe uri
     */
    private String buildCpeWithoutVersion(String name, String language){
        String cpe="";
        switch (language){
            case "java":
                String jProducts=name.replace("/",":");
                jProducts= StrUtil.toUnderlineCase(jProducts);
                cpe="cpe:2.3:a:"+jProducts+":*:*:*:*:*:*:*:*";
                break;
            case "javaScript":
                String jsProducts=name.replace("/",":");
                cpe="cpe:2.3:a:"+jsProducts+":*:*:*:*:*:node.js:*:*";
                break;
            case "golang":
                if(name.startsWith("github.com/")){
                    String gProducts=name.substring(11);
                    gProducts=gProducts.replace("/",":");
                    cpe="cpe:2.3:a:"+gProducts+":*:*:*:*:*:*:*:*";
                }
                break;
            case "python":
                String pyProducts=name.replace("/",":");
                cpe="cpe:2.3:a:"+pyProducts+":*:*:*:*:*:*:*:*";
                break;
            default:
                break;
        }
        return cpe;
    }

    /**
     * 根据cve信息构造对应的漏洞简明信息
     * @param cveDO cve信息
     * @return 漏洞简明信息
     */
    private VulnerabilityBriefDTO buildVulnerabilityBriefInfo(CveDO cveDO){
        VulnerabilityBriefDTO briefDTO=new VulnerabilityBriefDTO();
        briefDTO.setCveId(cveDO.getCveId());
        briefDTO.setProblemType(cveDO.getProblemType());
        briefDTO.setCveAssigner(cveDO.getCveAssigner());
        briefDTO.setPublishedDate(cveDO.getPublishedDate());
        briefDTO.setLastModifiedDate(cveDO.getLastModifiedDate());
        if(cveDO.getCvss3().getAttackVector()!=null){
            briefDTO.setAttackType(cveDO.getCvss3().getAttackVector());
        }else if(cveDO.getCvss2().getAccessVector()!=null){
            briefDTO.setAttackType(cveDO.getCvss2().getAccessVector());
        }
        if(cveDO.getCvss3().getImpactScore()!=null){
            briefDTO.setCvss3Score(cveDO.getCvss3().getImpactScore());
        }
        if(cveDO.getCvss2().getImpactScore()!=null){
            briefDTO.setCvss2Score(cveDO.getCvss2().getImpactScore());
        }
        if(cveDO.getCvss3().getBaseSeverity()!=null){
            briefDTO.setSeverity(cveDO.getCvss3().getBaseSeverity());
        }else if(cveDO.getCvss3().getImpactScore()!=null){
            Double score=cveDO.getCvss3().getImpactScore();
            briefDTO.setSeverity(score>7.5?"HIGH":score>5?"MEDIUM":score>2.5?"LOW":"NONE");
        }else if(cveDO.getCvss2().getImpactScore()!=null){
            Double score=cveDO.getCvss2().getImpactScore();
            briefDTO.setSeverity(score>7.5?"HIGH":score>5?"MEDIUM":score>2.5?"LOW":"NONE");
        }else{
            briefDTO.setSeverity("UNKNOWN");
        }
        CnvdDO cnvdDO=cnvdDao.findOneByCveId(cveDO.getCveId());
        if(cnvdDO!=null){
            briefDTO.setCnvdId(cnvdDO.getCnvdId());
            briefDTO.setTitle(cnvdDO.getTitle());
            String cnSeverity=cnvdDO.getSeverity();
            if(null!=cnSeverity && (null==briefDTO.getSeverity() || !briefDTO.getSeverity().equals("UNKNOWN"))){
                briefDTO.setSeverity(cnSeverity.equals("高")?"HIGH":cnSeverity.equals("中")?"MEDIUM":cnSeverity.equals("低")?"LOW":"UNKNOWN");
            }
        }
        return briefDTO;
    }
}
